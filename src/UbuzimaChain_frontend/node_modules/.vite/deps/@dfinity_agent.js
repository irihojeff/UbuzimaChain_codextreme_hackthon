import {
  AgentError,
  Certificate,
  CertificateVerificationError,
  NodeId,
  Principal,
  blsVerify,
  bufEquals,
  canisterStatus_exports,
  cbor_exports,
  check_canister_ranges,
  compare,
  concat,
  decode,
  encode,
  flatten_forks,
  fromHex,
  hash,
  hashOfMap,
  hashTreeToString,
  hashValue,
  idl_exports,
  lebEncode,
  lookupResultToBuffer,
  lookup_path,
  reconstruct,
  request,
  requestIdOf,
  toHex,
  uint8ToBuf,
  verify
} from "./chunk-DU6DELUL.js";
import {
  require_buffer
} from "./chunk-JZIWKXYB.js";
import {
  ed25519
} from "./chunk-PDU7RDPN.js";
import {
  require_src2 as require_src
} from "./chunk-B7DFMRGV.js";
import {
  __export,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/@dfinity/agent/lib/esm/actor.js
var import_buffer6 = __toESM(require_buffer());

// node_modules/@dfinity/agent/lib/esm/agent/api.js
var ReplicaRejectCode;
(function(ReplicaRejectCode2) {
  ReplicaRejectCode2[ReplicaRejectCode2["SysFatal"] = 1] = "SysFatal";
  ReplicaRejectCode2[ReplicaRejectCode2["SysTransient"] = 2] = "SysTransient";
  ReplicaRejectCode2[ReplicaRejectCode2["DestinationInvalid"] = 3] = "DestinationInvalid";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterReject"] = 4] = "CanisterReject";
  ReplicaRejectCode2[ReplicaRejectCode2["CanisterError"] = 5] = "CanisterError";
})(ReplicaRejectCode || (ReplicaRejectCode = {}));

// node_modules/@dfinity/agent/lib/esm/auth.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var domainSeparator = new TextEncoder().encode("\nic-request");
var SignIdentity = class {
  /**
   * Get the principal represented by this identity. Normally should be a
   * `Principal.selfAuthenticating()`.
   */
  getPrincipal() {
    if (!this._principal) {
      this._principal = Principal.selfAuthenticating(new Uint8Array(this.getPublicKey().toDer()));
    }
    return this._principal;
  }
  /**
   * Transform a request into a signed version of the request. This is done last
   * after the transforms on the body of a request. The returned object can be
   * anything, but must be serializable to CBOR.
   * @param request - internet computer request to transform
   */
  async transformRequest(request2) {
    const { body } = request2, fields = __rest(request2, ["body"]);
    const requestId = await requestIdOf(body);
    return Object.assign(Object.assign({}, fields), { body: {
      content: body,
      sender_pubkey: this.getPublicKey().toDer(),
      sender_sig: await this.sign(concat(domainSeparator, requestId))
    } });
  }
};
var AnonymousIdentity = class {
  getPrincipal() {
    return Principal.anonymous();
  }
  async transformRequest(request2) {
    return Object.assign(Object.assign({}, request2), { body: { content: request2.body } });
  }
};
function createIdentityDescriptor(identity) {
  const identityIndicator = "getPublicKey" in identity ? { type: "PublicKeyIdentity", publicKey: toHex(identity.getPublicKey().toDer()) } : { type: "AnonymousIdentity" };
  return identityIndicator;
}

// node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js
var cbor = __toESM(require_src());

// node_modules/@dfinity/agent/lib/esm/utils/random.js
var randomNumber = () => {
  if (typeof window !== "undefined" && !!window.crypto && !!window.crypto.getRandomValues) {
    const array = new Uint32Array(1);
    window.crypto.getRandomValues(array);
    return array[0];
  }
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    const array = new Uint32Array(1);
    crypto.getRandomValues(array);
    return array[0];
  }
  if (typeof crypto !== "undefined" && crypto.randomInt) {
    return crypto.randomInt(0, 4294967295);
  }
  return Math.floor(Math.random() * 4294967295);
};

// node_modules/@dfinity/agent/lib/esm/agent/http/types.js
var SubmitRequestType;
(function(SubmitRequestType2) {
  SubmitRequestType2["Call"] = "call";
})(SubmitRequestType || (SubmitRequestType = {}));
function makeNonce() {
  const buffer = new ArrayBuffer(16);
  const view = new DataView(buffer);
  const rand1 = randomNumber();
  const rand2 = randomNumber();
  const rand3 = randomNumber();
  const rand4 = randomNumber();
  view.setUint32(0, rand1);
  view.setUint32(4, rand2);
  view.setUint32(8, rand3);
  view.setUint32(12, rand4);
  return buffer;
}

// node_modules/@dfinity/agent/lib/esm/agent/http/transforms.js
var NANOSECONDS_PER_MILLISECONDS = BigInt(1e6);
var REPLICA_PERMITTED_DRIFT_MILLISECONDS = 60 * 1e3;
var Expiry = class {
  constructor(deltaInMSec) {
    const raw_value = BigInt(Math.floor(Date.now() + deltaInMSec - REPLICA_PERMITTED_DRIFT_MILLISECONDS)) * NANOSECONDS_PER_MILLISECONDS;
    const ingress_as_seconds = raw_value / BigInt(1e9);
    const ingress_as_minutes = ingress_as_seconds / BigInt(60);
    const rounded_down_nanos = ingress_as_minutes * BigInt(60) * BigInt(1e9);
    this._value = rounded_down_nanos;
  }
  toCBOR() {
    return cbor.value.u64(this._value.toString(16), 16);
  }
  toHash() {
    return lebEncode(this._value);
  }
};
function makeNonceTransform(nonceFn = makeNonce) {
  return async (request2) => {
    const headers = request2.request.headers;
    request2.request.headers = headers;
    if (request2.endpoint === "call") {
      request2.body.nonce = nonceFn();
    }
  };
}
function makeExpiryTransform(delayInMilliseconds) {
  return async (request2) => {
    request2.body.ingress_expiry = new Expiry(delayInMilliseconds);
  };
}
function httpHeadersTransform(headers) {
  const headerFields = [];
  headers.forEach((value2, key) => {
    headerFields.push([key, value2]);
  });
  return headerFields;
}

// node_modules/@dfinity/agent/lib/esm/agent/http/errors.js
var AgentHTTPResponseError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = this.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// node_modules/@dfinity/agent/lib/esm/utils/expirableMap.js
var __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ExpirableMap_inner;
var _ExpirableMap_expirationTime;
var _a;
var _b;
var ExpirableMap = class {
  /**
   * Create a new ExpirableMap.
   * @param {ExpirableMapOptions<any, any>} options - options for the map.
   * @param {Iterable<[any, any]>} options.source - an optional source of entries to initialize the map with.
   * @param {number} options.expirationTime - the time in milliseconds after which entries will expire.
   */
  constructor(options = {}) {
    _ExpirableMap_inner.set(this, void 0);
    _ExpirableMap_expirationTime.set(this, void 0);
    this[_a] = this.entries.bind(this);
    this[_b] = "ExpirableMap";
    const { source = [], expirationTime = 10 * 60 * 1e3 } = options;
    const currentTime = Date.now();
    __classPrivateFieldSet(this, _ExpirableMap_inner, new Map([...source].map(([key, value2]) => [key, { value: value2, timestamp: currentTime }])), "f");
    __classPrivateFieldSet(this, _ExpirableMap_expirationTime, expirationTime, "f");
  }
  /**
   * Prune removes all expired entries.
   */
  prune() {
    const currentTime = Date.now();
    for (const [key, entry] of __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries()) {
      if (currentTime - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, "f")) {
        __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
      }
    }
    return this;
  }
  // Implementing the Map interface
  /**
   * Set the value for the given key. Prunes expired entries.
   * @param key for the entry
   * @param value of the entry
   * @returns this
   */
  set(key, value2) {
    this.prune();
    const entry = {
      value: value2,
      timestamp: Date.now()
    };
    __classPrivateFieldGet(this, _ExpirableMap_inner, "f").set(key, entry);
    return this;
  }
  /**
   * Get the value associated with the key, if it exists and has not expired.
   * @param key K
   * @returns the value associated with the key, or undefined if the key is not present or has expired.
   */
  get(key) {
    const entry = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").get(key);
    if (entry === void 0) {
      return void 0;
    }
    if (Date.now() - entry.timestamp > __classPrivateFieldGet(this, _ExpirableMap_expirationTime, "f")) {
      __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
      return void 0;
    }
    return entry.value;
  }
  /**
   * Clear all entries.
   */
  clear() {
    __classPrivateFieldGet(this, _ExpirableMap_inner, "f").clear();
  }
  /**
   * Entries returns the entries of the map, without the expiration time.
   * @returns an iterator over the entries of the map.
   */
  entries() {
    const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries();
    const generator = function* () {
      for (const [key, value2] of iterator) {
        yield [key, value2.value];
      }
    };
    return generator();
  }
  /**
   * Values returns the values of the map, without the expiration time.
   * @returns an iterator over the values of the map.
   */
  values() {
    const iterator = __classPrivateFieldGet(this, _ExpirableMap_inner, "f").values();
    const generator = function* () {
      for (const value2 of iterator) {
        yield value2.value;
      }
    };
    return generator();
  }
  /**
   * Keys returns the keys of the map
   * @returns an iterator over the keys of the map.
   */
  keys() {
    return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").keys();
  }
  /**
   * forEach calls the callbackfn on each entry of the map.
   * @param callbackfn to call on each entry
   * @param thisArg to use as this when calling the callbackfn
   */
  forEach(callbackfn, thisArg) {
    for (const [key, value2] of __classPrivateFieldGet(this, _ExpirableMap_inner, "f").entries()) {
      callbackfn.call(thisArg, value2.value, key, this);
    }
  }
  /**
   * has returns true if the key exists and has not expired.
   * @param key K
   * @returns true if the key exists and has not expired.
   */
  has(key) {
    return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").has(key);
  }
  /**
   * delete the entry for the given key.
   * @param key K
   * @returns true if the key existed and has been deleted.
   */
  delete(key) {
    return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").delete(key);
  }
  /**
   * get size of the map.
   * @returns the size of the map.
   */
  get size() {
    return __classPrivateFieldGet(this, _ExpirableMap_inner, "f").size;
  }
};
_ExpirableMap_inner = /* @__PURE__ */ new WeakMap(), _ExpirableMap_expirationTime = /* @__PURE__ */ new WeakMap(), _a = Symbol.iterator, _b = Symbol.toStringTag;

// node_modules/@dfinity/agent/lib/esm/der.js
var encodeLenBytes = (len) => {
  if (len <= 127) {
    return 1;
  } else if (len <= 255) {
    return 2;
  } else if (len <= 65535) {
    return 3;
  } else if (len <= 16777215) {
    return 4;
  } else {
    throw new Error("Length too long (> 4 bytes)");
  }
};
var encodeLen = (buf, offset, len) => {
  if (len <= 127) {
    buf[offset] = len;
    return 1;
  } else if (len <= 255) {
    buf[offset] = 129;
    buf[offset + 1] = len;
    return 2;
  } else if (len <= 65535) {
    buf[offset] = 130;
    buf[offset + 1] = len >> 8;
    buf[offset + 2] = len;
    return 3;
  } else if (len <= 16777215) {
    buf[offset] = 131;
    buf[offset + 1] = len >> 16;
    buf[offset + 2] = len >> 8;
    buf[offset + 3] = len;
    return 4;
  } else {
    throw new Error("Length too long (> 4 bytes)");
  }
};
var decodeLenBytes = (buf, offset) => {
  if (buf[offset] < 128)
    return 1;
  if (buf[offset] === 128)
    throw new Error("Invalid length 0");
  if (buf[offset] === 129)
    return 2;
  if (buf[offset] === 130)
    return 3;
  if (buf[offset] === 131)
    return 4;
  throw new Error("Length too long (> 4 bytes)");
};
var decodeLen = (buf, offset) => {
  const lenBytes = decodeLenBytes(buf, offset);
  if (lenBytes === 1)
    return buf[offset];
  else if (lenBytes === 2)
    return buf[offset + 1];
  else if (lenBytes === 3)
    return (buf[offset + 1] << 8) + buf[offset + 2];
  else if (lenBytes === 4)
    return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];
  throw new Error("Length too long (> 4 bytes)");
};
var DER_COSE_OID = Uint8Array.from([
  ...[48, 12],
  ...[6, 10],
  ...[43, 6, 1, 4, 1, 131, 184, 67, 1, 1]
  // DER encoded COSE
]);
var ED25519_OID = Uint8Array.from([
  ...[48, 5],
  ...[6, 3],
  ...[43, 101, 112]
  // id-Ed25519 OID
]);
var SECP256K1_OID = Uint8Array.from([
  ...[48, 16],
  ...[6, 7],
  ...[42, 134, 72, 206, 61, 2, 1],
  ...[6, 5],
  ...[43, 129, 4, 0, 10]
  // OID secp256k1
]);
function wrapDER(payload, oid) {
  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);
  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;
  let offset = 0;
  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);
  buf[offset++] = 48;
  offset += encodeLen(buf, offset, len);
  buf.set(oid, offset);
  offset += oid.byteLength;
  buf[offset++] = 3;
  offset += encodeLen(buf, offset, payload.byteLength + 1);
  buf[offset++] = 0;
  buf.set(new Uint8Array(payload), offset);
  return buf;
}
var unwrapDER = (derEncoded, oid) => {
  let offset = 0;
  const expect = (n, msg) => {
    if (buf[offset++] !== n) {
      throw new Error("Expected: " + msg);
    }
  };
  const buf = new Uint8Array(derEncoded);
  expect(48, "sequence");
  offset += decodeLenBytes(buf, offset);
  if (!bufEquals(buf.slice(offset, offset + oid.byteLength), oid)) {
    throw new Error("Not the expected OID.");
  }
  offset += oid.byteLength;
  expect(3, "bit string");
  const payloadLen = decodeLen(buf, offset) - 1;
  offset += decodeLenBytes(buf, offset);
  expect(0, "0 padding");
  const result = buf.slice(offset);
  if (payloadLen !== result.length) {
    throw new Error(`DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`);
  }
  return result;
};

// node_modules/@dfinity/agent/lib/esm/public_key.js
var __classPrivateFieldSet2 = function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Ed25519PublicKey_rawKey;
var _Ed25519PublicKey_derKey;
var Ed25519PublicKey = class _Ed25519PublicKey {
  // `fromRaw` and `fromDer` should be used for instantiation, not this constructor.
  constructor(key) {
    _Ed25519PublicKey_rawKey.set(this, void 0);
    _Ed25519PublicKey_derKey.set(this, void 0);
    if (key.byteLength !== _Ed25519PublicKey.RAW_KEY_LENGTH) {
      throw new Error("An Ed25519 public key must be exactly 32bytes long");
    }
    __classPrivateFieldSet2(this, _Ed25519PublicKey_rawKey, key, "f");
    __classPrivateFieldSet2(this, _Ed25519PublicKey_derKey, _Ed25519PublicKey.derEncode(key), "f");
  }
  static from(key) {
    return this.fromDer(key.toDer());
  }
  static fromRaw(rawKey) {
    return new _Ed25519PublicKey(rawKey);
  }
  static fromDer(derKey) {
    return new _Ed25519PublicKey(this.derDecode(derKey));
  }
  static derEncode(publicKey) {
    return wrapDER(publicKey, ED25519_OID).buffer;
  }
  static derDecode(key) {
    const unwrapped = unwrapDER(key, ED25519_OID);
    if (unwrapped.length !== this.RAW_KEY_LENGTH) {
      throw new Error("An Ed25519 public key must be exactly 32bytes long");
    }
    return unwrapped;
  }
  get rawKey() {
    return __classPrivateFieldGet2(this, _Ed25519PublicKey_rawKey, "f");
  }
  get derKey() {
    return __classPrivateFieldGet2(this, _Ed25519PublicKey_derKey, "f");
  }
  toDer() {
    return this.derKey;
  }
  toRaw() {
    return this.rawKey;
  }
};
_Ed25519PublicKey_rawKey = /* @__PURE__ */ new WeakMap(), _Ed25519PublicKey_derKey = /* @__PURE__ */ new WeakMap();
Ed25519PublicKey.RAW_KEY_LENGTH = 32;

// node_modules/@dfinity/agent/lib/esm/agent/http/index.js
var __classPrivateFieldSet3 = function(receiver, state, value2, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HttpAgent_queryPipeline;
var _HttpAgent_updatePipeline;
var _HttpAgent_subnetKeys;
var _HttpAgent_verifyQuerySignatures;
var _HttpAgent_verifyQueryResponse;
var RequestStatusResponseStatus;
(function(RequestStatusResponseStatus2) {
  RequestStatusResponseStatus2["Received"] = "received";
  RequestStatusResponseStatus2["Processing"] = "processing";
  RequestStatusResponseStatus2["Replied"] = "replied";
  RequestStatusResponseStatus2["Rejected"] = "rejected";
  RequestStatusResponseStatus2["Unknown"] = "unknown";
  RequestStatusResponseStatus2["Done"] = "done";
})(RequestStatusResponseStatus || (RequestStatusResponseStatus = {}));
var DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS = 5 * 60 * 1e3;
var IC_ROOT_KEY = "308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100814c0e6ec71fab583b08bd81373c255c3c371b2e84863c98a4f1e08b74235d14fb5d9c0cd546d9685f913a0c0b2cc5341583bf4b4392e467db96d65b9bb4cb717112f8472e0d5a4d14505ffd7484b01291091c5f87b98883463f98091a0baaae";
var IC0_DOMAIN = "ic0.app";
var IC0_SUB_DOMAIN = ".ic0.app";
var ICP0_DOMAIN = "icp0.io";
var ICP0_SUB_DOMAIN = ".icp0.io";
var ICP_API_DOMAIN = "icp-api.io";
var ICP_API_SUB_DOMAIN = ".icp-api.io";
var HttpDefaultFetchError = class extends AgentError {
  constructor(message) {
    super(message);
    this.message = message;
  }
};
var IdentityInvalidError = class extends AgentError {
  constructor(message) {
    super(message);
    this.message = message;
  }
};
function getDefaultFetch() {
  let defaultFetch;
  if (typeof window !== "undefined") {
    if (window.fetch) {
      defaultFetch = window.fetch.bind(window);
    } else {
      throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a browser context, but window.fetch was not present.");
    }
  } else if (typeof globalThis !== "undefined") {
    if (globalThis.fetch) {
      defaultFetch = globalThis.fetch.bind(globalThis);
    } else {
      throw new HttpDefaultFetchError("Fetch implementation was not available. You appear to be in a Node.js context, but global.fetch was not available.");
    }
  } else if (typeof self !== "undefined") {
    if (self.fetch) {
      defaultFetch = self.fetch.bind(self);
    }
  }
  if (defaultFetch) {
    return defaultFetch;
  }
  throw new HttpDefaultFetchError("Fetch implementation was not available. Please provide fetch to the HttpAgent constructor, or ensure it is available in the window or global context.");
}
var HttpAgent = class _HttpAgent {
  constructor(options = {}) {
    this.rootKey = fromHex(IC_ROOT_KEY);
    this._timeDiffMsecs = 0;
    this._rootKeyFetched = false;
    this._isAgent = true;
    _HttpAgent_queryPipeline.set(this, []);
    _HttpAgent_updatePipeline.set(this, []);
    _HttpAgent_subnetKeys.set(this, new ExpirableMap({
      expirationTime: 5 * 60 * 1e3
      // 5 minutes
    }));
    _HttpAgent_verifyQuerySignatures.set(this, true);
    _HttpAgent_verifyQueryResponse.set(this, (queryResponse, subnetStatus) => {
      if (__classPrivateFieldGet3(this, _HttpAgent_verifyQuerySignatures, "f") === false) {
        return queryResponse;
      }
      if (!subnetStatus) {
        throw new CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");
      }
      const { status, signatures = [], requestId } = queryResponse;
      const domainSeparator2 = new TextEncoder().encode("\vic-response");
      for (const sig of signatures) {
        const { timestamp, identity } = sig;
        const nodeId = Principal.fromUint8Array(identity).toText();
        let hash2;
        if (status === "replied") {
          const { reply } = queryResponse;
          hash2 = hashOfMap({
            status,
            reply,
            timestamp: BigInt(timestamp),
            request_id: requestId
          });
        } else if (status === "rejected") {
          const { reject_code, reject_message, error_code } = queryResponse;
          hash2 = hashOfMap({
            status,
            reject_code,
            reject_message,
            error_code,
            timestamp: BigInt(timestamp),
            request_id: requestId
          });
        } else {
          throw new Error(`Unknown status: ${status}`);
        }
        const separatorWithHash = concat(domainSeparator2, new Uint8Array(hash2));
        const pubKey = subnetStatus === null || subnetStatus === void 0 ? void 0 : subnetStatus.nodeKeys.get(nodeId);
        if (!pubKey) {
          throw new CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");
        }
        const rawKey = Ed25519PublicKey.fromDer(pubKey).rawKey;
        const valid = ed25519.verify(sig.signature, new Uint8Array(separatorWithHash), new Uint8Array(rawKey));
        if (valid)
          return queryResponse;
        throw new CertificateVerificationError(`Invalid signature from replica ${nodeId} signed query.`);
      }
      return queryResponse;
    });
    if (options.source) {
      if (!(options.source instanceof _HttpAgent)) {
        throw new Error("An Agent's source can only be another HttpAgent");
      }
      this._identity = options.source._identity;
      this._fetch = options.source._fetch;
      this._host = options.source._host;
      this._credentials = options.source._credentials;
    } else {
      this._fetch = options.fetch || getDefaultFetch() || fetch.bind(globalThis);
      this._fetchOptions = options.fetchOptions;
      this._callOptions = options.callOptions;
    }
    if (options.host !== void 0) {
      if (!options.host.match(/^[a-z]+:/) && typeof window !== "undefined") {
        this._host = new URL(window.location.protocol + "//" + options.host);
      } else {
        this._host = new URL(options.host);
      }
    } else if (options.source !== void 0) {
      this._host = options.source._host;
    } else {
      const location = typeof window !== "undefined" ? window.location : void 0;
      if (!location) {
        this._host = new URL("https://icp-api.io");
        console.warn("Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.");
      }
      const knownHosts = ["ic0.app", "icp0.io", "127.0.0.1", "localhost"];
      const hostname = location === null || location === void 0 ? void 0 : location.hostname;
      let knownHost;
      if (hostname && typeof hostname === "string") {
        knownHost = knownHosts.find((host) => hostname.endsWith(host));
      }
      if (location && knownHost) {
        this._host = new URL(`${location.protocol}//${knownHost}${location.port ? ":" + location.port : ""}`);
      } else {
        this._host = new URL("https://icp-api.io");
        console.warn("Could not infer host from window.location, defaulting to mainnet gateway of https://icp-api.io. Please provide a host to the HttpAgent constructor to avoid this warning.");
      }
    }
    if (options.verifyQuerySignatures !== void 0) {
      __classPrivateFieldSet3(this, _HttpAgent_verifyQuerySignatures, options.verifyQuerySignatures, "f");
    }
    this._retryTimes = options.retryTimes !== void 0 && options.retryTimes >= 0 ? options.retryTimes : 3;
    if (this._host.hostname.endsWith(IC0_SUB_DOMAIN)) {
      this._host.hostname = IC0_DOMAIN;
    } else if (this._host.hostname.endsWith(ICP0_SUB_DOMAIN)) {
      this._host.hostname = ICP0_DOMAIN;
    } else if (this._host.hostname.endsWith(ICP_API_SUB_DOMAIN)) {
      this._host.hostname = ICP_API_DOMAIN;
    }
    if (options.credentials) {
      const { name, password } = options.credentials;
      this._credentials = `${name}${password ? ":" + password : ""}`;
    }
    this._identity = Promise.resolve(options.identity || new AnonymousIdentity());
    this.addTransform("update", makeNonceTransform(makeNonce));
    if (options.useQueryNonces) {
      this.addTransform("query", makeNonceTransform(makeNonce));
    }
  }
  isLocal() {
    const hostname = this._host.hostname;
    return hostname === "127.0.0.1" || hostname.endsWith("127.0.0.1");
  }
  addTransform(type, fn, priority = fn.priority || 0) {
    if (type === "update") {
      const i = __classPrivateFieldGet3(this, _HttpAgent_updatePipeline, "f").findIndex((x) => (x.priority || 0) < priority);
      __classPrivateFieldGet3(this, _HttpAgent_updatePipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet3(this, _HttpAgent_updatePipeline, "f").length, 0, Object.assign(fn, { priority }));
    } else if (type === "query") {
      const i = __classPrivateFieldGet3(this, _HttpAgent_queryPipeline, "f").findIndex((x) => (x.priority || 0) < priority);
      __classPrivateFieldGet3(this, _HttpAgent_queryPipeline, "f").splice(i >= 0 ? i : __classPrivateFieldGet3(this, _HttpAgent_queryPipeline, "f").length, 0, Object.assign(fn, { priority }));
    }
  }
  async getPrincipal() {
    if (!this._identity) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    return (await this._identity).getPrincipal();
  }
  async call(canisterId, options, identity) {
    const id = await (identity !== void 0 ? await identity : await this._identity);
    if (!id) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const canister = Principal.from(canisterId);
    const ecid = options.effectiveCanisterId ? Principal.from(options.effectiveCanisterId) : canister;
    const sender = id.getPrincipal() || Principal.anonymous();
    let ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS);
    if (Math.abs(this._timeDiffMsecs) > 1e3 * 30) {
      ingress_expiry = new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS + this._timeDiffMsecs);
    }
    const submit = {
      request_type: SubmitRequestType.Call,
      canister_id: canister,
      method_name: options.methodName,
      arg: options.arg,
      sender,
      ingress_expiry
    };
    let transformedRequest = await this._transform({
      request: {
        body: null,
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "call",
      body: submit
    });
    transformedRequest = await id.transformRequest(transformedRequest);
    const body = encode(transformedRequest.body);
    const request2 = this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${ecid.toText()}/call`, this._host), Object.assign(Object.assign(Object.assign({}, this._callOptions), transformedRequest.request), { body })));
    const [response, requestId] = await Promise.all([request2, requestIdOf(submit)]);
    const responseBuffer = await response.arrayBuffer();
    const responseBody = response.status === 200 && responseBuffer.byteLength > 0 ? decode(responseBuffer) : null;
    return {
      requestId,
      response: {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        body: responseBody,
        headers: httpHeadersTransform(response.headers)
      }
    };
  }
  async _requestAndRetry(request2, tries = 0) {
    let response;
    try {
      response = await request2();
    } catch (error) {
      if (this._retryTimes > tries) {
        console.warn(`Caught exception while attempting to make request:
  ${error}
  Retrying request.`);
        return await this._requestAndRetry(request2, tries + 1);
      }
      throw error;
    }
    if (response.ok) {
      return response;
    }
    const responseText = await response.clone().text();
    const errorMessage = `Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${responseText}
`;
    if (this._retryTimes > tries) {
      console.warn(errorMessage + `  Retrying request.`);
      return await this._requestAndRetry(request2, tries + 1);
    }
    throw new AgentHTTPResponseError(errorMessage, {
      ok: response.ok,
      status: response.status,
      statusText: response.statusText,
      headers: httpHeadersTransform(response.headers)
    });
  }
  async query(canisterId, fields, identity) {
    const makeQuery = async () => {
      const id = await (identity !== void 0 ? await identity : await this._identity);
      if (!id) {
        throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
      }
      const canister = Principal.from(canisterId);
      const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();
      const request2 = {
        request_type: "query",
        canister_id: canister,
        method_name: fields.methodName,
        arg: fields.arg,
        sender,
        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)
      };
      const requestId = await requestIdOf(request2);
      let transformedRequest = await this._transform({
        request: {
          method: "POST",
          headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
        },
        endpoint: "read",
        body: request2
      });
      transformedRequest = await (id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest));
      const body = encode(transformedRequest.body);
      const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister.toText()}/query`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
      const queryResponse = decode(await response.arrayBuffer());
      return Object.assign(Object.assign({}, queryResponse), { httpDetails: {
        ok: response.ok,
        status: response.status,
        statusText: response.statusText,
        headers: httpHeadersTransform(response.headers)
      }, requestId });
    };
    const getSubnetStatus = async () => {
      if (!__classPrivateFieldGet3(this, _HttpAgent_verifyQuerySignatures, "f")) {
        return void 0;
      }
      const subnetStatus2 = __classPrivateFieldGet3(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());
      if (subnetStatus2) {
        return subnetStatus2;
      }
      await this.fetchSubnetKeys(canisterId.toString());
      return __classPrivateFieldGet3(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());
    };
    const [query, subnetStatus] = await Promise.all([makeQuery(), getSubnetStatus()]);
    if (!__classPrivateFieldGet3(this, _HttpAgent_verifyQuerySignatures, "f")) {
      return query;
    }
    try {
      return __classPrivateFieldGet3(this, _HttpAgent_verifyQueryResponse, "f").call(this, query, subnetStatus);
    } catch (_) {
      console.warn("Query response verification failed. Retrying with fresh subnet keys.");
      __classPrivateFieldGet3(this, _HttpAgent_subnetKeys, "f").delete(canisterId.toString());
      await this.fetchSubnetKeys(canisterId.toString());
      const updatedSubnetStatus = __classPrivateFieldGet3(this, _HttpAgent_subnetKeys, "f").get(canisterId.toString());
      if (!updatedSubnetStatus) {
        throw new CertificateVerificationError("Invalid signature from replica signed query: no matching node key found.");
      }
      return __classPrivateFieldGet3(this, _HttpAgent_verifyQueryResponse, "f").call(this, query, updatedSubnetStatus);
    }
  }
  async createReadStateRequest(fields, identity) {
    const id = await (identity !== void 0 ? await identity : await this._identity);
    if (!id) {
      throw new IdentityInvalidError("This identity has expired due this application's security policy. Please refresh your authentication.");
    }
    const sender = (id === null || id === void 0 ? void 0 : id.getPrincipal()) || Principal.anonymous();
    const transformedRequest = await this._transform({
      request: {
        method: "POST",
        headers: Object.assign({ "Content-Type": "application/cbor" }, this._credentials ? { Authorization: "Basic " + btoa(this._credentials) } : {})
      },
      endpoint: "read_state",
      body: {
        request_type: "read_state",
        paths: fields.paths,
        sender,
        ingress_expiry: new Expiry(DEFAULT_INGRESS_EXPIRY_DELTA_IN_MSECS)
      }
    });
    return id === null || id === void 0 ? void 0 : id.transformRequest(transformedRequest);
  }
  async readState(canisterId, fields, identity, request2) {
    const canister = typeof canisterId === "string" ? Principal.fromText(canisterId) : canisterId;
    const transformedRequest = request2 !== null && request2 !== void 0 ? request2 : await this.createReadStateRequest(fields, identity);
    const body = encode(transformedRequest.body);
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/canister/${canister}/read_state`, this._host), Object.assign(Object.assign(Object.assign({}, this._fetchOptions), transformedRequest.request), { body })));
    if (!response.ok) {
      throw new Error(`Server returned an error:
  Code: ${response.status} (${response.statusText})
  Body: ${await response.text()}
`);
    }
    return decode(await response.arrayBuffer());
  }
  /**
   * Allows agent to sync its time with the network. Can be called during intialization or mid-lifecycle if the device's clock has drifted away from the network time. This is necessary to set the Expiry for a request
   * @param {Principal} canisterId - Pass a canister ID if you need to sync the time with a particular replica. Uses the management canister by default
   */
  async syncTime(canisterId) {
    const CanisterStatus = await import("./canisterStatus-KXTP5SVW.js");
    const callTime = Date.now();
    try {
      if (!canisterId) {
        console.log("Syncing time with the IC. No canisterId provided, so falling back to ryjl3-tyaaa-aaaaa-aaaba-cai");
      }
      const status = await CanisterStatus.request({
        // Fall back with canisterId of the ICP Ledger
        canisterId: canisterId !== null && canisterId !== void 0 ? canisterId : Principal.from("ryjl3-tyaaa-aaaaa-aaaba-cai"),
        agent: this,
        paths: ["time"]
      });
      const replicaTime = status.get("time");
      if (replicaTime) {
        this._timeDiffMsecs = Number(replicaTime) - Number(callTime);
      }
    } catch (error) {
      console.error("Caught exception while attempting to sync time:", error);
    }
  }
  async status() {
    const headers = this._credentials ? {
      Authorization: "Basic " + btoa(this._credentials)
    } : {};
    const response = await this._requestAndRetry(() => this._fetch("" + new URL(`/api/v2/status`, this._host), Object.assign({ headers }, this._fetchOptions)));
    return decode(await response.arrayBuffer());
  }
  async fetchRootKey() {
    if (!this._rootKeyFetched) {
      this.rootKey = (await this.status()).root_key;
      this._rootKeyFetched = true;
    }
    return this.rootKey;
  }
  invalidateIdentity() {
    this._identity = null;
  }
  replaceIdentity(identity) {
    this._identity = Promise.resolve(identity);
  }
  async fetchSubnetKeys(canisterId) {
    const effectiveCanisterId = Principal.from(canisterId);
    const response = await request({
      canisterId: effectiveCanisterId,
      paths: ["subnet"],
      agent: this
    });
    const subnetResponse = response.get("subnet");
    if (subnetResponse && typeof subnetResponse === "object" && "nodeKeys" in subnetResponse) {
      __classPrivateFieldGet3(this, _HttpAgent_subnetKeys, "f").set(effectiveCanisterId.toText(), subnetResponse);
      return subnetResponse;
    }
    return void 0;
  }
  _transform(request2) {
    let p = Promise.resolve(request2);
    if (request2.endpoint === "call") {
      for (const fn of __classPrivateFieldGet3(this, _HttpAgent_updatePipeline, "f")) {
        p = p.then((r) => fn(r).then((r2) => r2 || r));
      }
    } else {
      for (const fn of __classPrivateFieldGet3(this, _HttpAgent_queryPipeline, "f")) {
        p = p.then((r) => fn(r).then((r2) => r2 || r));
      }
    }
    return p;
  }
};
_HttpAgent_queryPipeline = /* @__PURE__ */ new WeakMap(), _HttpAgent_updatePipeline = /* @__PURE__ */ new WeakMap(), _HttpAgent_subnetKeys = /* @__PURE__ */ new WeakMap(), _HttpAgent_verifyQuerySignatures = /* @__PURE__ */ new WeakMap(), _HttpAgent_verifyQueryResponse = /* @__PURE__ */ new WeakMap();

// node_modules/@dfinity/agent/lib/esm/agent/proxy.js
var ProxyMessageKind;
(function(ProxyMessageKind2) {
  ProxyMessageKind2["Error"] = "err";
  ProxyMessageKind2["GetPrincipal"] = "gp";
  ProxyMessageKind2["GetPrincipalResponse"] = "gpr";
  ProxyMessageKind2["Query"] = "q";
  ProxyMessageKind2["QueryResponse"] = "qr";
  ProxyMessageKind2["Call"] = "c";
  ProxyMessageKind2["CallResponse"] = "cr";
  ProxyMessageKind2["ReadState"] = "rs";
  ProxyMessageKind2["ReadStateResponse"] = "rsr";
  ProxyMessageKind2["Status"] = "s";
  ProxyMessageKind2["StatusResponse"] = "sr";
})(ProxyMessageKind || (ProxyMessageKind = {}));
var ProxyStubAgent = class {
  constructor(_frontend, _agent) {
    this._frontend = _frontend;
    this._agent = _agent;
  }
  onmessage(msg) {
    switch (msg.type) {
      case ProxyMessageKind.GetPrincipal:
        this._agent.getPrincipal().then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind.GetPrincipalResponse,
            response: response.toText()
          });
        });
        break;
      case ProxyMessageKind.Query:
        this._agent.query(...msg.args).then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind.QueryResponse,
            response
          });
        });
        break;
      case ProxyMessageKind.Call:
        this._agent.call(...msg.args).then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind.CallResponse,
            response
          });
        });
        break;
      case ProxyMessageKind.ReadState:
        this._agent.readState(...msg.args).then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind.ReadStateResponse,
            response
          });
        });
        break;
      case ProxyMessageKind.Status:
        this._agent.status().then((response) => {
          this._frontend({
            id: msg.id,
            type: ProxyMessageKind.StatusResponse,
            response
          });
        });
        break;
      default:
        throw new Error(`Invalid message received: ${JSON.stringify(msg)}`);
    }
  }
};
var ProxyAgent = class {
  constructor(_backend) {
    this._backend = _backend;
    this._nextId = 0;
    this._pendingCalls = /* @__PURE__ */ new Map();
    this.rootKey = null;
  }
  onmessage(msg) {
    const id = msg.id;
    const maybePromise = this._pendingCalls.get(id);
    if (!maybePromise) {
      throw new Error("A proxy get the same message twice...");
    }
    this._pendingCalls.delete(id);
    const [resolve, reject] = maybePromise;
    switch (msg.type) {
      case ProxyMessageKind.Error:
        return reject(msg.error);
      case ProxyMessageKind.GetPrincipalResponse:
      case ProxyMessageKind.CallResponse:
      case ProxyMessageKind.QueryResponse:
      case ProxyMessageKind.ReadStateResponse:
      case ProxyMessageKind.StatusResponse:
        return resolve(msg.response);
      default:
        throw new Error(`Invalid message being sent to ProxyAgent: ${JSON.stringify(msg)}`);
    }
  }
  async getPrincipal() {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind.GetPrincipal
    }).then((principal) => {
      if (typeof principal !== "string") {
        throw new Error("Invalid principal received.");
      }
      return Principal.fromText(principal);
    });
  }
  readState(canisterId, fields) {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind.ReadState,
      args: [canisterId.toString(), fields]
    });
  }
  call(canisterId, fields) {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind.Call,
      args: [canisterId.toString(), fields]
    });
  }
  status() {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind.Status
    });
  }
  query(canisterId, fields) {
    return this._sendAndWait({
      id: this._nextId++,
      type: ProxyMessageKind.Query,
      args: [canisterId.toString(), fields]
    });
  }
  async _sendAndWait(msg) {
    return new Promise((resolve, reject) => {
      this._pendingCalls.set(msg.id, [resolve, reject]);
      this._backend(msg);
    });
  }
  async fetchRootKey() {
    const rootKey = (await this.status()).root_key;
    this.rootKey = rootKey;
    return rootKey;
  }
};

// node_modules/@dfinity/agent/lib/esm/agent/index.js
function getDefaultAgent() {
  const agent = typeof window === "undefined" ? typeof globalThis === "undefined" ? typeof self === "undefined" ? void 0 : self.ic.agent : globalThis.ic.agent : window.ic.agent;
  if (!agent) {
    throw new Error("No Agent could be found.");
  }
  return agent;
}

// node_modules/@dfinity/agent/lib/esm/polling/index.js
var polling_exports = {};
__export(polling_exports, {
  defaultStrategy: () => defaultStrategy,
  pollForResponse: () => pollForResponse,
  strategy: () => strategy_exports
});

// node_modules/@dfinity/agent/lib/esm/polling/strategy.js
var strategy_exports = {};
__export(strategy_exports, {
  backoff: () => backoff,
  chain: () => chain,
  conditionalDelay: () => conditionalDelay,
  defaultStrategy: () => defaultStrategy,
  maxAttempts: () => maxAttempts,
  once: () => once,
  throttle: () => throttle,
  timeout: () => timeout
});
var FIVE_MINUTES_IN_MSEC = 5 * 60 * 1e3;
function defaultStrategy() {
  return chain(conditionalDelay(once(), 1e3), backoff(1e3, 1.2), timeout(FIVE_MINUTES_IN_MSEC));
}
function once() {
  let first = true;
  return async () => {
    if (first) {
      first = false;
      return true;
    }
    return false;
  };
}
function conditionalDelay(condition, timeInMsec) {
  return async (canisterId, requestId, status) => {
    if (await condition(canisterId, requestId, status)) {
      return new Promise((resolve) => setTimeout(resolve, timeInMsec));
    }
  };
}
function maxAttempts(count) {
  let attempts = count;
  return async (canisterId, requestId, status) => {
    if (--attempts <= 0) {
      throw new Error(`Failed to retrieve a reply for request after ${count} attempts:
  Request ID: ${toHex(requestId)}
  Request status: ${status}
`);
    }
  };
}
function throttle(throttleInMsec) {
  return () => new Promise((resolve) => setTimeout(resolve, throttleInMsec));
}
function timeout(timeInMsec) {
  const end = Date.now() + timeInMsec;
  return async (canisterId, requestId, status) => {
    if (Date.now() > end) {
      throw new Error(`Request timed out after ${timeInMsec} msec:
  Request ID: ${toHex(requestId)}
  Request status: ${status}
`);
    }
  };
}
function backoff(startingThrottleInMsec, backoffFactor) {
  let currentThrottling = startingThrottleInMsec;
  return () => new Promise((resolve) => setTimeout(() => {
    currentThrottling *= backoffFactor;
    resolve();
  }, currentThrottling));
}
function chain(...strategies) {
  return async (canisterId, requestId, status) => {
    for (const a of strategies) {
      await a(canisterId, requestId, status);
    }
  };
}

// node_modules/@dfinity/agent/lib/esm/polling/index.js
async function pollForResponse(agent, canisterId, requestId, strategy, request2, blsVerify2) {
  var _a2;
  const path = [new TextEncoder().encode("request_status"), requestId];
  const currentRequest = request2 !== null && request2 !== void 0 ? request2 : await ((_a2 = agent.createReadStateRequest) === null || _a2 === void 0 ? void 0 : _a2.call(agent, { paths: [path] }));
  const state = await agent.readState(canisterId, { paths: [path] }, void 0, currentRequest);
  if (agent.rootKey == null)
    throw new Error("Agent root key not initialized before polling");
  const cert = await Certificate.create({
    certificate: state.certificate,
    rootKey: agent.rootKey,
    canisterId,
    blsVerify: blsVerify2
  });
  const maybeBuf = cert.lookup([...path, new TextEncoder().encode("status")]);
  let status;
  if (typeof maybeBuf === "undefined") {
    status = RequestStatusResponseStatus.Unknown;
  } else {
    status = new TextDecoder().decode(maybeBuf);
  }
  switch (status) {
    case RequestStatusResponseStatus.Replied: {
      return cert.lookup([...path, "reply"]);
    }
    case RequestStatusResponseStatus.Received:
    case RequestStatusResponseStatus.Unknown:
    case RequestStatusResponseStatus.Processing:
      await strategy(canisterId, requestId, status);
      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);
    case RequestStatusResponseStatus.Rejected: {
      const rejectCode = new Uint8Array(cert.lookup([...path, "reject_code"]))[0];
      const rejectMessage = new TextDecoder().decode(cert.lookup([...path, "reject_message"]));
      throw new Error(`Call was rejected:
  Request ID: ${toHex(requestId)}
  Reject code: ${rejectCode}
  Reject text: ${rejectMessage}
`);
    }
    case RequestStatusResponseStatus.Done:
      throw new Error(`Call was marked as done but we never saw the reply:
  Request ID: ${toHex(requestId)}
`);
  }
  throw new Error("unreachable");
}

// node_modules/@dfinity/agent/lib/esm/canisters/management_idl.js
var management_idl_default = ({ IDL }) => {
  const canister_id = IDL.Principal;
  const definite_canister_settings = IDL.Record({
    controllers: IDL.Vec(IDL.Principal),
    freezing_threshold: IDL.Nat,
    memory_allocation: IDL.Nat,
    compute_allocation: IDL.Nat
  });
  const canister_settings = IDL.Record({
    controllers: IDL.Opt(IDL.Vec(IDL.Principal)),
    freezing_threshold: IDL.Opt(IDL.Nat),
    memory_allocation: IDL.Opt(IDL.Nat),
    compute_allocation: IDL.Opt(IDL.Nat)
  });
  const wasm_module = IDL.Vec(IDL.Nat8);
  return IDL.Service({
    canister_status: IDL.Func([IDL.Record({ canister_id })], [
      IDL.Record({
        status: IDL.Variant({
          stopped: IDL.Null,
          stopping: IDL.Null,
          running: IDL.Null
        }),
        memory_size: IDL.Nat,
        cycles: IDL.Nat,
        settings: definite_canister_settings,
        module_hash: IDL.Opt(IDL.Vec(IDL.Nat8))
      })
    ], []),
    create_canister: IDL.Func([IDL.Record({ settings: IDL.Opt(canister_settings) })], [IDL.Record({ canister_id })], []),
    delete_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    deposit_cycles: IDL.Func([IDL.Record({ canister_id })], [], []),
    install_code: IDL.Func([
      IDL.Record({
        arg: IDL.Vec(IDL.Nat8),
        wasm_module,
        mode: IDL.Variant({
          reinstall: IDL.Null,
          upgrade: IDL.Null,
          install: IDL.Null
        }),
        canister_id
      })
    ], [], []),
    provisional_create_canister_with_cycles: IDL.Func([
      IDL.Record({
        settings: IDL.Opt(canister_settings),
        amount: IDL.Opt(IDL.Nat)
      })
    ], [IDL.Record({ canister_id })], []),
    provisional_top_up_canister: IDL.Func([IDL.Record({ canister_id, amount: IDL.Nat })], [], []),
    raw_rand: IDL.Func([], [IDL.Vec(IDL.Nat8)], []),
    start_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    stop_canister: IDL.Func([IDL.Record({ canister_id })], [], []),
    uninstall_code: IDL.Func([IDL.Record({ canister_id })], [], []),
    update_settings: IDL.Func([
      IDL.Record({
        canister_id: IDL.Principal,
        settings: canister_settings
      })
    ], [], [])
  });
};

// node_modules/@dfinity/agent/lib/esm/actor.js
var ActorCallError = class extends AgentError {
  constructor(canisterId, methodName, type, props) {
    super([
      `Call failed:`,
      `  Canister: ${canisterId.toText()}`,
      `  Method: ${methodName} (${type})`,
      ...Object.getOwnPropertyNames(props).map((n) => `  "${n}": ${JSON.stringify(props[n])}`)
    ].join("\n"));
    this.canisterId = canisterId;
    this.methodName = methodName;
    this.type = type;
    this.props = props;
  }
};
var QueryCallRejectedError = class extends ActorCallError {
  constructor(canisterId, methodName, result) {
    var _a2;
    super(canisterId, methodName, "query", {
      Status: result.status,
      Code: (_a2 = ReplicaRejectCode[result.reject_code]) !== null && _a2 !== void 0 ? _a2 : `Unknown Code "${result.reject_code}"`,
      Message: result.reject_message
    });
    this.result = result;
  }
};
var UpdateCallRejectedError = class extends ActorCallError {
  constructor(canisterId, methodName, requestId, response) {
    super(canisterId, methodName, "update", Object.assign({ "Request ID": toHex(requestId) }, response.body ? Object.assign(Object.assign({}, response.body.error_code ? {
      "Error code": response.body.error_code
    } : {}), { "Reject code": String(response.body.reject_code), "Reject message": response.body.reject_message }) : {
      "HTTP status code": response.status.toString(),
      "HTTP status text": response.statusText
    }));
    this.requestId = requestId;
    this.response = response;
  }
};
var CanisterInstallMode;
(function(CanisterInstallMode2) {
  CanisterInstallMode2["Install"] = "install";
  CanisterInstallMode2["Reinstall"] = "reinstall";
  CanisterInstallMode2["Upgrade"] = "upgrade";
})(CanisterInstallMode || (CanisterInstallMode = {}));
var metadataSymbol = Symbol.for("ic-agent-metadata");
var Actor = class _Actor {
  constructor(metadata) {
    this[metadataSymbol] = Object.freeze(metadata);
  }
  /**
   * Get the Agent class this Actor would call, or undefined if the Actor would use
   * the default agent (global.ic.agent).
   * @param actor The actor to get the agent of.
   */
  static agentOf(actor) {
    return actor[metadataSymbol].config.agent;
  }
  /**
   * Get the interface of an actor, in the form of an instance of a Service.
   * @param actor The actor to get the interface of.
   */
  static interfaceOf(actor) {
    return actor[metadataSymbol].service;
  }
  static canisterIdOf(actor) {
    return Principal.from(actor[metadataSymbol].config.canisterId);
  }
  static async install(fields, config) {
    const mode = fields.mode === void 0 ? CanisterInstallMode.Install : fields.mode;
    const arg = fields.arg ? [...new Uint8Array(fields.arg)] : [];
    const wasmModule = [...new Uint8Array(fields.module)];
    const canisterId = typeof config.canisterId === "string" ? Principal.fromText(config.canisterId) : config.canisterId;
    await getManagementCanister(config).install_code({
      mode: { [mode]: null },
      arg,
      wasm_module: wasmModule,
      canister_id: canisterId
    });
  }
  static async createCanister(config) {
    const { canister_id: canisterId } = await getManagementCanister(config || {}).provisional_create_canister_with_cycles({ amount: [], settings: [] });
    return canisterId;
  }
  static async createAndInstallCanister(interfaceFactory, fields, config) {
    const canisterId = await this.createCanister(config);
    await this.install(Object.assign({}, fields), Object.assign(Object.assign({}, config), { canisterId }));
    return this.createActor(interfaceFactory, Object.assign(Object.assign({}, config), { canisterId }));
  }
  static createActorClass(interfaceFactory, options) {
    const service = interfaceFactory({ IDL: idl_exports });
    class CanisterActor extends _Actor {
      constructor(config) {
        if (!config.canisterId)
          throw new AgentError(`Canister ID is required, but received ${typeof config.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);
        const canisterId = typeof config.canisterId === "string" ? Principal.fromText(config.canisterId) : config.canisterId;
        super({
          config: Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), config), { canisterId }),
          service
        });
        for (const [methodName, func] of service._fields) {
          if (options === null || options === void 0 ? void 0 : options.httpDetails) {
            func.annotations.push(ACTOR_METHOD_WITH_HTTP_DETAILS);
          }
          this[methodName] = _createActorMethod(this, methodName, func, config.blsVerify);
        }
      }
    }
    return CanisterActor;
  }
  static createActor(interfaceFactory, configuration) {
    if (!configuration.canisterId) {
      throw new AgentError(`Canister ID is required, but received ${typeof configuration.canisterId} instead. If you are using automatically generated declarations, this may be because your application is not setting the canister ID in process.env correctly.`);
    }
    return new (this.createActorClass(interfaceFactory))(configuration);
  }
  static createActorWithHttpDetails(interfaceFactory, configuration) {
    return new (this.createActorClass(interfaceFactory, { httpDetails: true }))(configuration);
  }
};
function decodeReturnValue(types, msg) {
  const returnValues = idl_exports.decode(types, import_buffer6.Buffer.from(msg));
  switch (returnValues.length) {
    case 0:
      return void 0;
    case 1:
      return returnValues[0];
    default:
      return returnValues;
  }
}
var DEFAULT_ACTOR_CONFIG = {
  pollingStrategyFactory: strategy_exports.defaultStrategy
};
var ACTOR_METHOD_WITH_HTTP_DETAILS = "http-details";
function _createActorMethod(actor, methodName, func, blsVerify2) {
  let caller;
  if (func.annotations.includes("query") || func.annotations.includes("composite_query")) {
    caller = async (options, ...args) => {
      var _a2, _b2;
      options = Object.assign(Object.assign({}, options), (_b2 = (_a2 = actor[metadataSymbol].config).queryTransform) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const cid = Principal.from(options.canisterId || actor[metadataSymbol].config.canisterId);
      const arg = idl_exports.encode(func.argTypes, args);
      const result = await agent.query(cid, { methodName, arg });
      switch (result.status) {
        case "rejected":
          throw new QueryCallRejectedError(cid, methodName, result);
        case "replied":
          return func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS) ? {
            httpDetails: result.httpDetails,
            result: decodeReturnValue(func.retTypes, result.reply.arg)
          } : decodeReturnValue(func.retTypes, result.reply.arg);
      }
    };
  } else {
    caller = async (options, ...args) => {
      var _a2, _b2;
      options = Object.assign(Object.assign({}, options), (_b2 = (_a2 = actor[metadataSymbol].config).callTransform) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, methodName, args, Object.assign(Object.assign({}, actor[metadataSymbol].config), options)));
      const agent = options.agent || actor[metadataSymbol].config.agent || getDefaultAgent();
      const { canisterId, effectiveCanisterId, pollingStrategyFactory } = Object.assign(Object.assign(Object.assign({}, DEFAULT_ACTOR_CONFIG), actor[metadataSymbol].config), options);
      const cid = Principal.from(canisterId);
      const ecid = effectiveCanisterId !== void 0 ? Principal.from(effectiveCanisterId) : cid;
      const arg = idl_exports.encode(func.argTypes, args);
      const { requestId, response } = await agent.call(cid, {
        methodName,
        arg,
        effectiveCanisterId: ecid
      });
      if (!response.ok || response.body) {
        throw new UpdateCallRejectedError(cid, methodName, requestId, response);
      }
      const pollStrategy = pollingStrategyFactory();
      const responseBytes = await pollForResponse(agent, ecid, requestId, pollStrategy, blsVerify2);
      const shouldIncludeHttpDetails = func.annotations.includes(ACTOR_METHOD_WITH_HTTP_DETAILS);
      if (responseBytes !== void 0) {
        return shouldIncludeHttpDetails ? {
          httpDetails: response,
          result: decodeReturnValue(func.retTypes, responseBytes)
        } : decodeReturnValue(func.retTypes, responseBytes);
      } else if (func.retTypes.length === 0) {
        return shouldIncludeHttpDetails ? {
          httpDetails: response,
          result: void 0
        } : void 0;
      } else {
        throw new Error(`Call was returned undefined, but type [${func.retTypes.join(",")}].`);
      }
    };
  }
  const handler = (...args) => caller({}, ...args);
  handler.withOptions = (options) => (...args) => caller(options, ...args);
  return handler;
}
function getManagementCanister(config) {
  function transform(_methodName, args, _callConfig) {
    const first = args[0];
    let effectiveCanisterId = Principal.fromHex("");
    if (first && typeof first === "object" && first.canister_id) {
      effectiveCanisterId = Principal.from(first.canister_id);
    }
    return { effectiveCanisterId };
  }
  return Actor.createActor(management_idl_default, Object.assign(Object.assign(Object.assign({}, config), { canisterId: Principal.fromHex("") }), {
    callTransform: transform,
    queryTransform: transform
  }));
}

// node_modules/@dfinity/agent/lib/esm/canisters/asset_idl.js
var asset_idl_default = ({ IDL }) => {
  return IDL.Service({
    retrieve: IDL.Func([IDL.Text], [IDL.Vec(IDL.Nat8)], ["query"]),
    store: IDL.Func([IDL.Text, IDL.Vec(IDL.Nat8)], [], [])
  });
};

// node_modules/@dfinity/agent/lib/esm/canisters/asset.js
function createAssetCanisterActor(config) {
  return Actor.createActor(asset_idl_default, config);
}

// node_modules/@dfinity/agent/lib/esm/fetch_candid.js
async function fetchCandid(canisterId, agent) {
  if (!agent) {
    agent = new HttpAgent();
    if (agent.isLocal()) {
      agent.fetchRootKey();
    }
  }
  const status = await request({
    agent,
    canisterId: Principal.fromText(canisterId),
    paths: ["candid"]
  });
  const candid = status.get("candid");
  if (candid) {
    return candid;
  }
  const tmpHackInterface = ({ IDL }) => IDL.Service({
    __get_candid_interface_tmp_hack: IDL.Func([], [IDL.Text], ["query"])
  });
  const actor = Actor.createActor(tmpHackInterface, { agent, canisterId });
  return await actor.__get_candid_interface_tmp_hack();
}
export {
  ACTOR_METHOD_WITH_HTTP_DETAILS,
  Actor,
  ActorCallError,
  AnonymousIdentity,
  CanisterInstallMode,
  canisterStatus_exports as CanisterStatus,
  cbor_exports as Cbor,
  Certificate,
  CertificateVerificationError,
  DER_COSE_OID,
  ED25519_OID,
  Ed25519PublicKey,
  Expiry,
  HttpAgent,
  IdentityInvalidError,
  NodeId,
  ProxyAgent,
  ProxyMessageKind,
  ProxyStubAgent,
  QueryCallRejectedError,
  ReplicaRejectCode,
  RequestStatusResponseStatus,
  SECP256K1_OID,
  SignIdentity,
  SubmitRequestType,
  UpdateCallRejectedError,
  blsVerify,
  bufEquals,
  check_canister_ranges,
  compare,
  concat,
  createAssetCanisterActor,
  createIdentityDescriptor,
  decodeLen,
  decodeLenBytes,
  encodeLen,
  encodeLenBytes,
  fetchCandid,
  flatten_forks,
  fromHex,
  getDefaultAgent,
  getManagementCanister,
  hash,
  hashOfMap,
  hashTreeToString,
  hashValue,
  httpHeadersTransform,
  lookupResultToBuffer,
  lookup_path,
  makeExpiryTransform,
  makeNonce,
  makeNonceTransform,
  polling_exports as polling,
  randomNumber,
  reconstruct,
  requestIdOf,
  toHex,
  uint8ToBuf,
  unwrapDER,
  verify,
  wrapDER
};
//# sourceMappingURL=@dfinity_agent.js.map
